# Redis

### 介绍：

Redis 是用C语言编写的一个，单线程，高性能（键值对存储），基于内存运行并支持持久化的一个nosql数据库

### 能做什么：

分布式锁，队列，缓存

### Redis中的分页：

scan关键字，两部分组成：scan 0 match * count 100 

match * ：正则表达式，相等于模糊查询里的like

0 和 100：表示0-100条数据

- 返回结果：游标跟key值，当游标为0时代表查询结束

### Redis持久化操作：

什么叫持久化：在指定时间间隔中，将内存中的数据集快照写入磁盘，它恢复时是讲快照文件直接读到内存

**Redis 4.0之后支持AOF,RDB混合使用， 不过得先开启AOF**

#### RDB：

概念原理：Redis单独创建(fork)一个与当前进程一模一样的子进程来进行持久化（ps: ps - ef | grep redis 有两个Redis进程显示），这个子线程的所有数据（变量，环境变量，程序计数器等）都和原线程一模一样，会先将数据写入到一个临时文件中，待持久化结束了，再用这个临时文件替换上次持久化好的文件，整个过程中，主线程不需要进行任何IO操作，这就确保了极高的性能。

如何触发RDB：

1. shutdown且没开启AOF时（shutdown跟宕机不是一个意思）
2. 根据配置文件中默认的快照配置手动执行save或bgsave命令
   1. save只是管保存，其他不管，全部阻塞。
   2. bgsave，redis会在后台异步执行快照操作，同时相应客户端的请求
3. flushAll 命令，但是无意义，因为快照文件里面是空的主从复制中从机复制主机中的数据(全量复制，默认调用bgsave命令)

![img](https://uploader.shimo.im/f/VdV6DDTt9s0fUKtQ.png!thumbnail)

**缺点：**数据丢失会比AOF大，fork子进程CPU占用太大，性能不高

#### AOF：

概念原理：将Redis的操作日志以追加的方式写入文件，读操作是不记录的（增删改成功的记录才写入文件）

配置文件中，AOF默认不开启，将appendonly no 更改为 appendonly yes

AOF重写概念：将AOF文件瘦身，自动删除多余重复的操作，重写后文件表笑。如从64mb重写为32mb的文件，其中内容为.rdb文件的二进制（4.0版本之后）

AOF重写也代表混合持久化机制。

##### AOF重写如何触发：

1. aof文件大小超过(配置文件中默认64 Mb，但我们可以人为修改)
2. aof文件增长比例（配置文件中配置），比如你重写之后为AOF文件为30 Mb，增长比率为100时，等你AOF文件达到60 Mb时才会进行AOF操作。
3. 手动执行重写命令：bgrewriteaof

#### RDB跟AOF的比较：

.rdb里面存的是二进制文件，且与.aop相比，.rdb文件明显小于.aof

#### 混合持久化：

优点：加速度快，增量数据以AOF的形式保存，更少的数据丢失

缺点：兼容性差。4.0版本之前的Redis不识别该类AOF文件，同时由于前部分是RDB格式，可阅读行差

小总结：

1. Redis提供了RDB方式，为什么还要有AOF？
   1. AOAOF数据丢失少，而RDB会丢失最后一次快照的数据F数据丢失少，而RDB会丢失最后一次快照的数据
2. 如果AOF与RDB同时开启，谁优先？
   1. AOF
3. RDB与AOF优劣？
   1.  RDB适合大规模的数据恢复，对数据的完整性和一致性要求不高，AOF根据配项而定









